/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.5.2 .\otter.glb -Ttse
*/

import * as THREE from "three";
import React, { useEffect, useMemo, useRef, useState } from "react";
import { useFrame, useGraph } from "@react-three/fiber";
import { useGLTF } from "@react-three/drei";
import { GLTF, MeshSurfaceSampler, SkeletonUtils } from "three-stdlib";
import { createNoise4D } from "simplex-noise";

type GLTFResult = GLTF & {
  nodes: {
    body: THREE.SkinnedMesh;
    eyes: THREE.SkinnedMesh;
    nose: THREE.SkinnedMesh;
    whisker1: THREE.SkinnedMesh;
    whisker2: THREE.SkinnedMesh;
    whisker3: THREE.SkinnedMesh;
    whisker4: THREE.SkinnedMesh;
    spine: THREE.Bone;
  };
  materials: {
    otter: THREE.MeshStandardMaterial;
    eye: THREE.MeshStandardMaterial;
    nose: THREE.MeshStandardMaterial;
    whiskers: THREE.MeshStandardMaterial;
  };
};

const FUR_POINTS = 100000;

export function Otter(props: JSX.IntrinsicElements["group"]) {
  const { scene } = useGLTF("/models/otter/otter-transformed.glb");
  const clone = React.useMemo(() => SkeletonUtils.clone(scene), [scene]);
  const { nodes, materials } = useGraph(clone) as GLTFResult;

  // const [otterBodyRef, setOtterBodyRef] = useState<THREE.SkinnedMesh | null>(
  //   null
  // );

  // const noise = useMemo(() => createNoise4D(), []);

  // const fur = useRef<THREE.Vector3[]>([]);
  // const furGeometry = useRef<THREE.BufferGeometry>(new THREE.BufferGeometry());

  // const meshRef = useRef<THREE.Group | null>(null);

  // Animate the fur
  // useFrame(({ clock }) => {
  //   // if (!meshRef.current) return;

  //   // for (let i = 0; i < FUR_POINTS; i += 2) {
  //   //   const start = fur.current[i];
  //   //   const end = fur.current[i + 1];

  //   //   const angle = noise(start.x, start.y, start.z, clock.elapsedTime);

  //   //   const vec = end.clone();
  //   //   vec.cross(end.normal);

  //   //   const x = Math.cos(angle) * 2;
  //   //   const y = Math.sin(angle) * 2;

  //   //   const rad1 = vec.multiplyScalar(x);
  //   //   const rad2 = vec.multiplyScalar(y);

  //   //   // X, Y, Z
  //   //   furGeometry.current.attributes.position.array[(i + 1) * 3] =
  //   //     end.x + rad1.x + rad2.x;
  //   //   furGeometry.current.attributes.position.array[(i + 1) * 3 + 1] =
  //   //     end.y + rad1.y + rad2.y;
  //   //   furGeometry.current.attributes.position.array[(i + 1) * 3 + 2] =
  //   //     end.z + rad1.z + rad2.z;
  //   // }

  //   // // Trigger update
  //   // furGeometry.current.attributes.position.needsUpdate = true;
  // });

  // Fur
  // useEffect(() => {
  //   if (!otterBodyRef) {
  //     return;
  //   }

  //   const sampler = new MeshSurfaceSampler(otterBodyRef).build();

  //   const position = new THREE.Vector3();
  //   const normal = new THREE.Vector3();

  //   for (let i = 0; i < FUR_POINTS; i++) {
  //     sampler.sample(position, normal);

  //     fur.current.push(position.clone());

  //     const end = normal.clone();
  //     end.normal = position.clone();

  //     end.multiplyScalar(0.01 * Math.random() + 0.01).add(position);

  //     fur.current.push(end);
  //   }

  //   furGeometry.current.setFromPoints(fur.current);
  // }, [otterBodyRef]);

  return (
    <group
      {...props}
      dispose={null}
      // ref={meshRef}
    >
      <primitive object={nodes.spine} />
      <skinnedMesh
        geometry={nodes.body.geometry}
        material={materials.otter}
        skeleton={nodes.body.skeleton}
        // ref={(ref) => setOtterBodyRef(ref)}
      />
      <skinnedMesh
        geometry={nodes.eyes.geometry}
        material={materials.eye}
        skeleton={nodes.eyes.skeleton}
      />
      <skinnedMesh
        geometry={nodes.nose.geometry}
        material={materials.nose}
        skeleton={nodes.nose.skeleton}
      />
      <skinnedMesh
        geometry={nodes.whisker1.geometry}
        material={materials.whiskers}
        skeleton={nodes.whisker1.skeleton}
      />
      <skinnedMesh
        geometry={nodes.whisker2.geometry}
        material={materials.whiskers}
        skeleton={nodes.whisker2.skeleton}
      />
      <skinnedMesh
        geometry={nodes.whisker3.geometry}
        material={materials.whiskers}
        skeleton={nodes.whisker3.skeleton}
      />
      <skinnedMesh
        geometry={nodes.whisker4.geometry}
        material={materials.whiskers}
        skeleton={nodes.whisker4.skeleton}
      />

      {/* <lineSegments>
        <bufferGeometry ref={furGeometry} />
        <lineBasicMaterial color={"#43382F"} />
      </lineSegments> */}
    </group>
  );
}

useGLTF.preload("/models/otter/otter-transformed.glb");
